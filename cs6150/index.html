<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="shortcut icon" href="/images/favicon.png" />

<title>Fall 2025: CS 6150 Graduate Algorithm&nbsp;|&nbsp; :)</title>
<meta
  name="title"
  content="Fall 2025: CS 6150 Graduate Algorithm"
/>
<meta
  name="description"
  content="Week 1 Three key steps Describe algorithm Analyze time complexity Prove correctness: proof by induction Proof by Induction Base case Induction assumption Induction claim Proof Conclusion Binary Search: Inductive proof: Theorem: Given a sorted array A of n elements, binary search correctly finds the index of a target value T if T is in A.
Proof by Induction on the size of the array n:
Base Case (n=1): If the array has only one element, A[0], we compare it to the target T."
/>
<meta
  name="keywords"
  content=""
/>

  <meta name="author" content="Lee Wei" />




<meta property="og:title" content="Fall 2025: CS 6150 Graduate Algorithm" />
<meta property="og:description" content="Week 1 Three key steps Describe algorithm Analyze time complexity Prove correctness: proof by induction Proof by Induction Base case Induction assumption Induction claim Proof Conclusion Binary Search: Inductive proof: Theorem: Given a sorted array A of n elements, binary search correctly finds the index of a target value T if T is in A.
Proof by Induction on the size of the array n:
Base Case (n=1): If the array has only one element, A[0], we compare it to the target T." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://leewei.co/cs6150/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2025-09-10T21:22:23-06:00" />
<meta property="article:modified_time" content="2025-09-10T21:22:23-06:00" />




<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Fall 2025: CS 6150 Graduate Algorithm"/>
<meta name="twitter:description" content="Week 1 Three key steps Describe algorithm Analyze time complexity Prove correctness: proof by induction Proof by Induction Base case Induction assumption Induction claim Proof Conclusion Binary Search: Inductive proof: Theorem: Given a sorted array A of n elements, binary search correctly finds the index of a target value T if T is in A.
Proof by Induction on the size of the array n:
Base Case (n=1): If the array has only one element, A[0], we compare it to the target T."/>




<meta itemprop="name" content="Fall 2025: CS 6150 Graduate Algorithm">
<meta itemprop="description" content="Week 1 Three key steps Describe algorithm Analyze time complexity Prove correctness: proof by induction Proof by Induction Base case Induction assumption Induction claim Proof Conclusion Binary Search: Inductive proof: Theorem: Given a sorted array A of n elements, binary search correctly finds the index of a target value T if T is in A.
Proof by Induction on the size of the array n:
Base Case (n=1): If the array has only one element, A[0], we compare it to the target T."><meta itemprop="datePublished" content="2025-09-10T21:22:23-06:00" />
<meta itemprop="dateModified" content="2025-09-10T21:22:23-06:00" />
<meta itemprop="wordCount" content="1096">
<meta itemprop="keywords" content="" />
<meta name="referrer" content="no-referrer-when-downgrade" />

    
    
    
    <link href="/bundle.min.css" rel="stylesheet" />

    

    


    
</head>

  <body>
    <header>
      <nav>
  <a
    href="/"
    
    >Home</a
  >

  <a
    href="/blog/"
    
    >Blog</a
  >


  <a href="/index.xml">
    <svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 448 512">
      
      <path
        d="M0 64C0 46.3 14.3 32 32 32c229.8 0 416 186.2 416 416c0 17.7-14.3 32-32 32s-32-14.3-32-32C384 253.6 226.4 96 32 96C14.3 96 0 81.7 0 64zM0 416a64 64 0 1 1 128 0A64 64 0 1 1 0 416zM32 160c159.1 0 288 128.9 288 288c0 17.7-14.3 32-32 32s-32-14.3-32-32c0-123.7-100.3-224-224-224c-17.7 0-32-14.3-32-32s14.3-32 32-32z"
      />
    </svg>
    RSS
  </a>

</nav>

<h1>Fall 2025: CS 6150 Graduate Algorithm</h1>


    </header>
    <main>
      
  
    
      <p>
        <i>
          <time
            style="color: var(--text-light);"
            datetime="2025-09-10"
            pubdate
          >
            2025-09-10
          </time>
        </i>
      </p>
    
  
  
  <content>
    <h3 id="week-1">Week 1</h3>
<ul>
<li>Three key steps
<ul>
<li>Describe algorithm</li>
<li>Analyze time complexity</li>
<li>Prove correctness: proof by induction</li>
</ul>
</li>
<li><strong>Proof by Induction</strong>
<ul>
<li>Base case</li>
<li>Induction assumption</li>
<li>Induction claim</li>
<li>Proof</li>
<li>Conclusion</li>
</ul>
</li>
<li><strong>Binary Search: Inductive proof</strong>:</li>
</ul>
<p><strong>Theorem</strong>: Given a sorted array <code>A</code> of <code>n</code> elements, binary search correctly finds the index of a target value <code>T</code> if <code>T</code> is in <code>A</code>.</p>
<p><strong>Proof by Induction on the size of the array <code>n</code>:</strong></p>
<ul>
<li>
<p><strong>Base Case (n=1)</strong>: If the array has only one element, <code>A[0]</code>, we compare it to the target <code>T</code>. If <code>A[0] == T</code>, we have found the element at index 0. If not, the element is not in the array. The algorithm works correctly for the base case.</p>
</li>
<li>
<p><strong>Inductive Hypothesis</strong>: Assume that for any sorted array of size <code>k &lt; n</code>, binary search correctly finds the target value if it is present.</p>
</li>
<li>
<p><strong>Inductive Step (for an array of size n)</strong>:</p>
<ol>
<li>Binary search first compares the target <code>T</code> with the middle element of the array, <code>A[mid]</code>, where <code>mid = floor(n/2)</code>.</li>
<li><strong>Case 1: <code>A[mid] == T</code></strong>: The element is found at index <code>mid</code>. The algorithm terminates and is correct.</li>
<li><strong>Case 2: <code>T &lt; A[mid]</code></strong>: If the target is less than the middle element, then <code>T</code> must be in the left subarray <code>A[0...mid-1]</code>, if it exists in the array at all. This left subarray is a sorted array of size <code>mid</code>, which is smaller than <code>n</code>. By the inductive hypothesis, binary search will correctly find <code>T</code> in this smaller subarray.</li>
<li><strong>Case 3: <code>T &gt; A[mid]</code></strong>: If the target is greater than the middle element, then <code>T</code> must be in the right subarray <code>A[mid+1...n-1]</code>, if it exists in the array at all. This right subarray is a sorted array of size <code>n - mid - 1</code>, which is smaller than <code>n</code>. By the inductive hypothesis, binary search will correctly find <code>T</code> in this smaller subarray.</li>
</ol>
</li>
<li>
<p><strong>Conclusion</strong>: In all cases, the algorithm either finds the target value or reduces the problem to a smaller subarray. By the principle of mathematical induction, binary search is correct for all <code>n &gt;= 1</code>.</p>
</li>
</ul>
<h4 id="time-complexity-of-binary-search">Time Complexity of Binary Search</h4>
<p>The time complexity of binary search can be described by the following recurrence relation:</p>
<p><code>T(n) = T(n/2) + c</code></p>
<p>Where:</p>
<ul>
<li><code>T(n)</code> is the time complexity for an array of size <code>n</code>.</li>
<li><code>T(n/2)</code> is the time taken to search in the subarray of size <code>n/2</code>.</li>
<li><code>c</code> is the constant time taken for the comparison and arithmetic operations.</li>
</ul>
<p>This recurrence can be solved using the <strong>Master Theorem</strong>:</p>
<p>For a recurrence of the form <code>T(n) = aT(n/b) + f(n)</code>, where <code>a &gt;= 1</code> and <code>b &gt; 1</code>, there are three cases. In our case, <code>a = 1</code>, <code>b = 2</code>, and <code>f(n) = c</code> (which is O(n^0)).
This falls into <strong>Case 2</strong> of the Master Theorem, where <code>f(n) = O(n^c)</code> and <code>c = log_b(a)</code>. Here, <code>log_b(a) = log_2(1) = 0</code>, so <code>c = 0</code>.
Therefore, the time complexity of binary search is <code>O(log n)</code>.</p>
<h4 id="master-theorem">Master Theorem</h4>
<p>The Master Theorem is a tool for solving recurrence relations of the form:</p>
<p><code>T(n) = aT(n/b) + f(n)</code></p>
<p>where <code>a &gt;= 1</code> and <code>b &gt; 1</code> are constants, and <code>f(n)</code> is an asymptotically positive function.</p>
<p>The theorem has three cases:</p>
<ul>
<li>
<p><strong>Case 1</strong>: If <code>f(n) = O(n^c)</code> for some constant <code>c &lt; log_b(a)</code>, then <code>T(n) = O(n^(log_b(a)))</code>.</p>
</li>
<li>
<p><strong>Case 2</strong>: If <code>f(n) = O(n^c * (log n)^k)</code> for some constants <code>c = log_b(a)</code> and <code>k &gt;= 0</code>, then <code>T(n) = O(n^c * (log n)^(k+1))</code>.</p>
<ul>
<li>A simpler version of this case is when <code>k=0</code>, if <code>f(n) = O(n^c)</code> where <code>c = log_b(a)</code>, then <code>T(n) = O(n^c * log n)</code>.</li>
</ul>
</li>
<li>
<p><strong>Case 3</strong>: If <code>f(n) = Omega(n^c)</code> for some constant <code>c &gt; log_b(a)</code>, and if <code>a * f(n/b) &lt;= k * f(n)</code> for some constant <code>k &lt; 1</code> and sufficiently large <code>n</code> (the &ldquo;regularity condition&rdquo;), then <code>T(n) = O(f(n))</code>.</p>
</li>
</ul>
<h3 id="week-2-data-structures-and-algorithmic-techniques">Week 2: Data Structures and Algorithmic Techniques</h3>
<ul>
<li><strong>Prefix Tree (Trie)</strong>: A tree-like data structure that stores a dynamic set of strings. Each node represents a common prefix of a set of strings.
<ul>
<li><strong>Time Complexity</strong>:
<ul>
<li><code>Insertion</code>: O(L), where L is the length of the string.</li>
<li><code>Search</code>: O(L).</li>
</ul>
</li>
<li><strong>Space Complexity</strong>: O(N*L), where N is the number of strings and L is their average length.</li>
</ul>
</li>
<li><strong>Problem</strong>: Given a collection of N documents, find all documents that contain a given set of m words.
<ul>
<li><strong>Naive Solution</strong>: Iterate through all N documents and for each document, check if it contains the m words. Time complexity: O(N * M * W), where W is the number of words in a document. A simpler view is O(N*m) if we consider the check for m words to be proportional to m.</li>
<li><strong>Inverted Index</strong>: A more efficient solution. For each word in the vocabulary, we store a list of documents in which it appears. To find documents containing a set of words, we take the intersection of the lists for each word.</li>
</ul>
</li>
<li><strong>Dynamic Arrays</strong>: A data structure that can grow in size. In C++, this is implemented as <code>std::vector</code>.
<ul>
<li>It starts with a certain capacity. When the capacity is reached, a new, larger array (usually double the size) is allocated, and all elements are copied over.</li>
<li><strong>Time Complexity</strong>:
<ul>
<li><code>Add</code> (to the end): O(1) on average (amortized), but O(n) in the worst case (when resizing).</li>
<li><code>Delete-from-end</code>: O(1).</li>
<li><code>Clear</code>: O(n).</li>
<li><code>Return i-th element</code>: O(1).</li>
</ul>
</li>
</ul>
</li>
<li><strong>Amortized Analysis</strong>: A method for analyzing the average performance of an algorithm over a sequence of operations, rather than the worst-case performance of a single operation.
<ul>
<li>Even if some operations are very slow, the average time over a sequence of N operations can be efficient, e.g., O(N) total time, which is O(1) amortized time per operation.</li>
</ul>
</li>
<li><strong>Divide and Conquer</strong>: An algorithmic paradigm that involves:
<ol>
<li><strong>Divide</strong>: Breaking the problem into smaller subproblems of the same type.</li>
<li><strong>Conquer</strong>: Solving the subproblems recursively.</li>
<li><strong>Combine</strong>: Combining the solutions to the subproblems to solve the original problem.</li>
</ol>
<ul>
<li>The correctness of divide and conquer algorithms is often proven by induction.</li>
</ul>
</li>
<li><strong>Merge Sort</strong>: A classic example of a divide and conquer algorithm for sorting.
<ul>
<li><strong>Algorithm</strong>:
<ol>
<li>Divide the array into two halves.</li>
<li>Recursively sort each half.</li>
<li>Merge the two sorted halves.</li>
</ol>
</li>
<li><strong>Time Complexity</strong>: <code>T(n) = 2T(n/2) + O(n)</code>, which resolves to <code>O(n log n)</code>.</li>
<li><strong>Proof by Induction</strong>:
<ul>
<li><strong>Base Case (n=1)</strong>: An array of size 1 is already sorted.</li>
<li><strong>Inductive Hypothesis</strong>: Assume that merge sort correctly sorts any array of size <code>k &lt; n</code>.</li>
<li><strong>Inductive Step (for an array of size n)</strong>: Merge sort recursively sorts two subarrays of size <code>n/2</code>. By the inductive hypothesis, these two subarrays are correctly sorted. The <code>merge</code> step then combines these two sorted subarrays into a single sorted array. Therefore, the entire array is sorted.</li>
</ul>
</li>
</ul>
</li>
</ul>

  </content>
  
  

    </main>
    <footer>
      
  <span>© 2024 Lee Wei</span>


  <span>
    |
    Made with
    <a href="https://github.com/maolonglong/hugo-simple/">Hugo ʕ•ᴥ•ʔ Simple</a>
  </span>


    </footer>

    
</body>
</html>
