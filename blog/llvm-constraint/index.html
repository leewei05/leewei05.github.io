<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="Introduction
Constraint Elimination is a transformation pass that extracts facts from LLVM IR and tries to replace certain uses with known facts. One common replacement is to replace conditional comparisons with constants (true or false) when known. The following is a simple example of how Constraint Elimination works.
int foo(int x, int y) {
  if (x &gt; y) {    // x &gt; y is a known fact in this block
    if (x &lt;= y) { // replace x &lt;= y with false
      return 2;
    }
    return 1;
  }

  return 0;
}

// after constraint elimination
int foo(int x, int y) {
  if (x &gt; y) {
    if (false) { // block can be removed
      return 2;
    }
    return 1;
  }

  return 0;
}
The logic behind Constraint Elimination relies on an analysis pass called the Constraint System. Constraint Elimination stores known facts inside two constraint systems (signed and unsigned) and asks the constraint system if it&rsquo;s okay to replace uses.">  

  <title>
    
      LLVM: Constraint Elimination Pass
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/" />
  
  
  
  <link rel="stylesheet" href="/css/main.86b11f1f715080789bb5a0ead6967929781ebe5c04e68254383a2782b333b5ed96b83ebc0e100098a235d1dc5f6851ed907b7022cbb5413e4a979dc634fe6cae.css" integrity="sha512-hrEfH3FQgHibtaDq1pZ5KXgevlwE5oJUODongrMzte2WuD68DhAAmKI10dxfaFHtkHtwIsu1QT5Kl53GNP5srg==" />
  
</head>
<body a="auto">
        <main class="page-content" aria-label="Content">
            <div class="w">
<a href="/">..</a>


<article>
    <p class="post-meta">
        <time datetime="2025-04-14 13:21:15 -0700 -0700">
            2025-04-14
        </time>
    </p>

    <h1>LLVM: Constraint Elimination Pass</h1>

    

    <h3 id="introduction">Introduction</h3>
<p>Constraint Elimination is a transformation pass that extracts facts from LLVM IR and tries to replace certain uses with known facts. One common replacement is to replace conditional comparisons with constants (true or false) when known. The following is a simple example of how Constraint Elimination works.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">foo</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&gt;</span> y) {    <span style="color:#75715e">// x &gt; y is a known fact in this block
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&lt;=</span> y) { <span style="color:#75715e">// replace x &lt;= y with false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// after constraint elimination
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">foo</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&gt;</span> y) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (false) { <span style="color:#75715e">// block can be removed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The logic behind Constraint Elimination relies on an analysis pass called the Constraint System. Constraint Elimination stores known facts inside two constraint systems (signed and unsigned) and asks the constraint system if it&rsquo;s okay to replace uses.</p>
<h3 id="constraint-system">Constraint System</h3>
<p>The Constraint System stores known facts in the following form (c0 is constant, c1 to cn are coefficients, v1 to vn are variables):</p>
<p><code>c0 &lt;= c1 * v1 + c2 * v2 … + cn * vn</code></p>
<p>For instance, constraint <code>x &gt;= 0</code> will be decomposed into <code>0 &lt;= 1 * x</code> and constraint <code>y &gt;= 0</code> will be decomposed into <code>0 &lt;= 0 * x + 1 * y</code>. These two constraints are <code>true</code> in the constraint system, which implies a <strong>logical AND</strong> between them, resulting in <code>x &gt;= 0 &amp;&amp; y &gt;= 0</code>.</p>
<p>Constraint Elimination will ask the constraint system whether a constraint (<code>A</code>) is implied by adding a negation of the constraint (<code>!A</code>) into the system. Since constraints are combined with logical AND, the system becomes <code>C1 &amp;&amp; C2 &amp;&amp; ... &amp;&amp; Cn &amp;&amp; !A</code>. If this is satisfiable (sat), there’s a solution where <code>A</code> is false, so <code>A</code> isn’t implied by the existing constraints. If unsatisfiable (unsat), no solution exists where <code>A</code> is false, meaning <code>A</code> must be true whenever the existing constraints hold. For example, with constraints <code>A &amp;&amp; B</code>, checking <code>A</code> by adding <code>!A</code> gives <code>A &amp;&amp; B &amp;&amp; !A</code>, which is unsat (a contradiction). Thus, <code>A</code> is implied and can be safely replaced with <code>true</code> in the ConstraintElimination pass.</p>
<p>Now that we understand how constraints are handled, let’s dive into the core of the Constraint Elimination pass.</p>
<h3 id="constraint-elimination">Constraint Elimination</h3>
<p>The Constraint Elimination pass works roughly as follows:</p>
<ol>
<li>Perform a Depth-First search the dominator tree and add entries to a worklist for every basic block. An entry can be a Fact to be added or a Check that needs to check if it can be replaced.</li>
<li>Sort the worklist by dominance information from the dominator tree.</li>
<li>Process sorted worklist and replace implied conditions.</li>
<li>Remove instructions with no uses inside the function.</li>
</ol>
<p>Constraint Elimination begins by traversing the <code>entry</code> block and iterates over every instruction. If there&rsquo;s a comparison instruction <code>icmp</code>, it adds an entry <code>UseCheck</code> into the worklist to check if it can be replaced later. If the terminator is a conditional branch, it adds corresponding facts to the successor blocks.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>define i1 <span style="color:#960050;background-color:#1e0010">@</span>src(i4 <span style="color:#f92672">%</span>x, i4 <span style="color:#f92672">%</span>y) {
</span></span><span style="display:flex;"><span>entry:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">%</span>c<span style="color:#ae81ff">.1</span> <span style="color:#f92672">=</span> icmp slt i4 <span style="color:#f92672">%</span>x, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  br i1 <span style="color:#f92672">%</span>c<span style="color:#ae81ff">.1</span>, label <span style="color:#f92672">%</span>t, label <span style="color:#f92672">%</span>f
</span></span><span style="display:flex;"><span>t:
</span></span><span style="display:flex;"><span>  ...x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>f:
</span></span><span style="display:flex;"><span>  ...x <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Branching to block <code>t</code> means that <code>%c.1</code> is true, where it can safely add <code>x &lt; 0</code> constraint to block <code>t</code>. On the other hand, it will invert the predicate to <code>x &gt;= 0</code> and add this constraint to block <code>f</code>. It will traverse to the next basic block and do the same until it traverses every basic block in the dominator tree.</p>
<p>Consider another example: block <code>t</code> is reached if <code>x &lt; 0 || y &lt; 0</code>. However, as mentioned earlier that the current constraint system has an implicit logical AND for every fact, constraint elimination cannot add this fact <code>x &lt; 0 || y &lt; 0</code> into the constraint system. As for block <code>f</code>, it can add the inverse of predicate <code>x &gt;= 0 &amp;&amp; y &gt;= 0</code> into the constraint system.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>define i1 <span style="color:#960050;background-color:#1e0010">@</span>src(i4 <span style="color:#f92672">%</span>x, i4 <span style="color:#f92672">%</span>y) {
</span></span><span style="display:flex;"><span>entry:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">%</span>c<span style="color:#ae81ff">.1</span> <span style="color:#f92672">=</span> icmp slt i4 <span style="color:#f92672">%</span>x, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">%</span>c<span style="color:#ae81ff">.2</span> <span style="color:#f92672">=</span> icmp slt i4 <span style="color:#f92672">%</span>y, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">%</span>or <span style="color:#f92672">=</span> or i1 <span style="color:#f92672">%</span>c<span style="color:#ae81ff">.1</span>, <span style="color:#f92672">%</span>c<span style="color:#ae81ff">.2</span>
</span></span><span style="display:flex;"><span>  br i1 <span style="color:#f92672">%</span>or, label <span style="color:#f92672">%</span>t, label <span style="color:#f92672">%</span>f
</span></span><span style="display:flex;"><span>t:
</span></span><span style="display:flex;"><span>  ret i1 false
</span></span><span style="display:flex;"><span>f:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">%</span>cmp <span style="color:#f92672">=</span> icmp sge i4 <span style="color:#f92672">%</span>x, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  ret i1 <span style="color:#f92672">%</span>cmp
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Below is the worklist after traversing all blocks in the function and sorting the worklist. <code>NumIn</code> and <code>NumOut</code> represent the sequence for the Depth-first search. The sorted entries follow these rules <code>NumIn &lt; ConditionFact &lt; Check &lt; InstrBefore</code>, where blocks with lower NumIn values dominate those with higher ones. In the same basic block, condition facts are processed before <code>UseCheck</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// entry NumIn=0, NumOut=5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// t     NumIn=1, Numout=2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// f     NumIn=3, Numout=4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>UseCheck(<span style="color:#f92672">%</span>c<span style="color:#ae81ff">.1</span>, ICMP_SLT, <span style="color:#f92672">%</span>x, <span style="color:#ae81ff">0</span>, NumIn<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, NumOut<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>UseCheck(<span style="color:#f92672">%</span>c<span style="color:#ae81ff">.2</span>, ICMP_SLT, <span style="color:#f92672">%</span>y, <span style="color:#ae81ff">0</span>, NumIn<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, NumOut<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>ConditionFact(DT.getNode(f), ICMP_SGE, <span style="color:#f92672">%</span>x, <span style="color:#ae81ff">0</span>, NumIn<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, NumOut<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>ConditionFact(DT.getNode(f), ICMP_SGE, <span style="color:#f92672">%</span>y, <span style="color:#ae81ff">0</span>, NumIn<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, NumOut<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>UseCheck(<span style="color:#f92672">%</span>cmp, ICMP_SGE, <span style="color:#f92672">%</span>x, <span style="color:#ae81ff">0</span>, NumIn<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, NumOut<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>)
</span></span></code></pre></div><p>By processing the above worklist, constraint elimination learns that it can replace <code>%cmp</code> with <code>true</code> in block <code>f</code> (see <a href="https://alive2.llvm.org/ce/z/MvjjwH">Alive2 proof</a> — a tool to verify LLVM IR optimizations), and safely remove <code>%cmp = icmp sge i4 %x, 0</code> instruction.</p>
<h3 id="missing-cases">Missing Cases</h3>
<p>As of writing, I have submitted a <a href="https://github.com/llvm/llvm-project/pull/132124">PR</a> to add optimization opportunities for Constraint Elimination. The pass adds additional facts if the condition being analyzed matches one of the following four patterns.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># bitwise OR</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>LHS | RHS &gt;<span style="color:#f92672">=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>&gt; LHS &gt;<span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> RHS &gt;<span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>LHS | RHS &gt; -1<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>&gt; LHS &gt;<span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> RHS &gt;<span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># bitwise AND</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>LHS &amp; RHS &lt; 0<span style="color:#f92672">)</span>   <span style="color:#f92672">=</span>&gt;  LHS &lt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> RHS &lt; <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>LHS &amp; RHS &lt;<span style="color:#f92672">=</span> -1<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>&gt;  LHS &lt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> RHS &lt; <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>This example demonstrates how my PR works. Before my PR, constraint elimination would only add one fact <code>%and.1 &lt; 0</code> to block <code>then</code>. With the added facts <code>x &lt; 0 &amp;&amp; y &lt; 0</code> in the <code>then</code> block, the pass can replace <code>%t.1</code> and <code>%t.2</code> with <code>true</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// before
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>define <span style="color:#66d9ef">void</span> <span style="color:#960050;background-color:#1e0010">@</span>src(i4 <span style="color:#f92672">%</span>x, i4 <span style="color:#f92672">%</span>y) {
</span></span><span style="display:flex;"><span>entry:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">%</span>and<span style="color:#ae81ff">.1</span> <span style="color:#f92672">=</span> and i4 <span style="color:#f92672">%</span>y, <span style="color:#f92672">%</span>x
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">%</span>c<span style="color:#ae81ff">.1</span><span style="color:#f92672">=</span> icmp slt i4 <span style="color:#f92672">%</span>and<span style="color:#ae81ff">.1</span>, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  br i1 <span style="color:#f92672">%</span>c<span style="color:#ae81ff">.1</span>, label <span style="color:#f92672">%</span>then, label <span style="color:#f92672">%</span>end
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>then:
</span></span><span style="display:flex;"><span>  ; fact: <span style="color:#f92672">%</span>and<span style="color:#ae81ff">.1</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">%</span>t<span style="color:#ae81ff">.1</span> <span style="color:#f92672">=</span> icmp slt i4 <span style="color:#f92672">%</span>x, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">%</span>t<span style="color:#ae81ff">.2</span> <span style="color:#f92672">=</span> icmp slt i4 <span style="color:#f92672">%</span>y, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  call <span style="color:#66d9ef">void</span> <span style="color:#960050;background-color:#1e0010">@</span>use(i1 <span style="color:#f92672">%</span>t<span style="color:#ae81ff">.1</span>)
</span></span><span style="display:flex;"><span>  call <span style="color:#66d9ef">void</span> <span style="color:#960050;background-color:#1e0010">@</span>use(i1 <span style="color:#f92672">%</span>t<span style="color:#ae81ff">.2</span>)
</span></span><span style="display:flex;"><span>  ret <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>end:
</span></span><span style="display:flex;"><span>  ret <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// after
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>define <span style="color:#66d9ef">void</span> <span style="color:#960050;background-color:#1e0010">@</span>tgt(i4 <span style="color:#f92672">%</span>x, i4 <span style="color:#f92672">%</span>y) {
</span></span><span style="display:flex;"><span>entry:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">%</span>and<span style="color:#ae81ff">.1</span> <span style="color:#f92672">=</span> and i4 <span style="color:#f92672">%</span>y, <span style="color:#f92672">%</span>x
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">%</span>c<span style="color:#ae81ff">.1</span><span style="color:#f92672">=</span> icmp slt i4 <span style="color:#f92672">%</span>and<span style="color:#ae81ff">.1</span>, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  br i1 <span style="color:#f92672">%</span>c<span style="color:#ae81ff">.1</span>, label <span style="color:#f92672">%</span>then, label <span style="color:#f92672">%</span>end
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>then:
</span></span><span style="display:flex;"><span>  call <span style="color:#66d9ef">void</span> <span style="color:#960050;background-color:#1e0010">@</span>use(i1 true)
</span></span><span style="display:flex;"><span>  call <span style="color:#66d9ef">void</span> <span style="color:#960050;background-color:#1e0010">@</span>use(i1 true)
</span></span><span style="display:flex;"><span>  ret <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>end:
</span></span><span style="display:flex;"><span>  ret <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="measure-replacement-counts">Measure Replacement Counts</h3>
<p>To evaluate the impact of my patch, I measured the number of replacements triggered by the Constraint Elimination pass. My approach is to print log whenever additional facts are added and replacement uses are triggered. This experiment was conducted on two projects, LLVM and Rust.</p>
<h4 id="building-llvm-with-ubsan-enabled">Building LLVM with UBSan enabled</h4>
<p>With UBSan enabled, building LLVM will go through a series of bound checks, firing more Constraint Elimination. The first build has my constraint elimination patch, and I commented out my patch in the second build.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># $CC_HOME points to my locally built LLVM</span>
</span></span><span style="display:flex;"><span>cmake -GNinja -DCMAKE_CXX_COMPILER<span style="color:#f92672">=</span>$CC_HOME/bin/clang++ <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -DCMAKE_C_COMPILER<span style="color:#f92672">=</span>$CC_HOME/bin/clang <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -DCMAKE_BUILD_TYPE<span style="color:#f92672">=</span>Release <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -DLLVM_ENABLE_PROJECTS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;llvm;clang&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -DLLVM_CCACHE_BUILD<span style="color:#f92672">=</span>OFF -DLLVM_BUILD_EXAMPLES<span style="color:#f92672">=</span>ON <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  ../llvm -DLLVM_TARGETS_TO_BUILD<span style="color:#f92672">=</span>X86 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -DLLVM_USE_SANITIZER<span style="color:#f92672">=</span>Undefined
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># without my patch</span>
</span></span><span style="display:flex;"><span>ninja -j <span style="color:#ae81ff">12</span> &gt; without.txt 2&gt;&amp;<span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># with my constraint elimination patch</span>
</span></span><span style="display:flex;"><span>ninja -j <span style="color:#ae81ff">12</span> &gt; with.txt 2&gt;&amp;<span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>We observed that Constraint Elimination added several new facts while building LLVM.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># without my patch</span>
</span></span><span style="display:flex;"><span>$ cat ce2/without.txt | grep <span style="color:#e6db74">&#34;additional&#34;</span> | wc -l
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># with my constraint elimination patch</span>
</span></span><span style="display:flex;"><span>$ cat ce2/with.txt | grep <span style="color:#e6db74">&#34;additional&#34;</span> | wc -l
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">78</span>
</span></span></code></pre></div><p>We expected that the extra facts could trigger more replacements. However, the total number of replace count is the same.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># without my patch</span>
</span></span><span style="display:flex;"><span>$ ./perform.sh ce/without.txt
</span></span><span style="display:flex;"><span>1: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">30428</span>
</span></span><span style="display:flex;"><span>2: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">517</span>
</span></span><span style="display:flex;"><span>3: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>4: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>5: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>6: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>7: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>total replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">30959</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># with my constraint elimination patch</span>
</span></span><span style="display:flex;"><span>$ ./perform.sh ce/with.txt
</span></span><span style="display:flex;"><span>1: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">30428</span>
</span></span><span style="display:flex;"><span>2: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">517</span>
</span></span><span style="display:flex;"><span>3: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>4: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>5: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>6: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>7: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>total replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">30959</span>
</span></span></code></pre></div><h4 id="building-rust-nightly">Building Rust nightly</h4>
<p>The result of the first experiment didn&rsquo;t meet what we expected, so we decided to see the result when compiling Rust.</p>
<p>As of writing, Rust nightly supports LLVM 20.x, so I had to rebuild my patch on top of LLVM 20. Luckily, there were no conflicts when I applied my updates to LLVM 20.x branch.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># bootstrap.toml for building rustc</span>
</span></span><span style="display:flex;"><span>change-id <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ignore&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>target.x86_64-unknown-linux-gnu<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># set external llvm-config to get our locally built LLVM binaries</span>
</span></span><span style="display:flex;"><span>llvm-config <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/home/lee/dev/llvm-project/build/bin/llvm-config&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>llvm<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>download-ci-llvm <span style="color:#f92672">=</span> false
</span></span><span style="display:flex;"><span>link-shared <span style="color:#f92672">=</span> false
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>build<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>extended <span style="color:#f92672">=</span> true
</span></span><span style="display:flex;"><span><span style="color:#75715e"># this needs to set to false, or rustc will try to build from in-tree LLVM</span>
</span></span><span style="display:flex;"><span>optimized-compiler-builtins <span style="color:#f92672">=</span> false
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>rust<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>channel <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;nightly&#34;</span>
</span></span></code></pre></div><p>Build stage2 <code>rustc</code> and <code>libstd</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># without my patch</span>
</span></span><span style="display:flex;"><span>./x.py build --stage <span style="color:#ae81ff">2</span> 2&gt;&amp;<span style="color:#ae81ff">1</span> | tee without.txt
</span></span><span style="display:flex;"><span><span style="color:#75715e"># with my constraint elimination patch</span>
</span></span><span style="display:flex;"><span>./x.py build --stage <span style="color:#ae81ff">2</span> 2&gt;&amp;<span style="color:#ae81ff">1</span> | tee with.txt
</span></span></code></pre></div><p>Like we expected, there were additional facts added when compiling rustc.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ cat rust-ce/without.txt | grep <span style="color:#e6db74">&#34;additional&#34;</span> | wc -l
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>$ cat rust-ce/with.txt | grep <span style="color:#e6db74">&#34;additional&#34;</span> | wc -l
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">304</span>
</span></span></code></pre></div><p>Finally, the result is similar to building LLVM. There was no difference in replacement count.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># without my patch</span>
</span></span><span style="display:flex;"><span>$ ./perform.sh rust-ce/without.txt
</span></span><span style="display:flex;"><span>1: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">594755</span>
</span></span><span style="display:flex;"><span>2: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">57</span>
</span></span><span style="display:flex;"><span>3: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>4: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>5: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>6: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>7: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>total replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">594812</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># with my constraint elimination patch</span>
</span></span><span style="display:flex;"><span>$ ./perform.sh rust-ce/with.txt
</span></span><span style="display:flex;"><span>1: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">594755</span>
</span></span><span style="display:flex;"><span>2: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">57</span>
</span></span><span style="display:flex;"><span>3: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>4: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>5: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>6: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>7: replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>total replace count
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">594812</span>
</span></span></code></pre></div><p>Given that Rust performs many bounds checks, we can observe that it benefits significantly from the Constraint Elimination pass overall.</p>
<p>Despite successfully adding additional facts, the total number of replacements remained unchanged in both LLVM and Rust builds. It&rsquo;s unclear why this happened. One possible explanation is that these new facts did not intersect with any existing <code>icmp</code> checks eligible for replacement. Further investigation is needed to understand this behavior.</p>
<h3 id="future-work">Future Work</h3>
<p>Constraint Elimination is a fun and powerful transformation pass. There are still many missing optimizations that we can contribute. As we mentioned earlier, the current constraint system supports only logical AND for its constraints. This limitation prevents the system from learning facts expressed as <code>Fact1 || Fact2</code>. Supporting logical OR opens many optimization opportunities, such as <code>(LHS | RHS) &lt; 0 =&gt; LHS &lt; 0 || RHS &lt; 0</code>.</p>
<p>Currently, <code>ne</code> constraints are not supported in the constraint system. The reason is that <code>a != b</code> cannot be directly encoded as a single linear constraint — it represents a disjunction: <code>a &lt; b || a &gt; b</code>. However, the constraint system models all facts as conjunctions (logical ANDs) of linear inequalities. Without support for logical OR, it is not possible to store <code>ne</code> facts within the system. In contrast, <code>eq</code> facts like <code>a == b</code> can be represented as two inequalities: <code>a &lt;= b &amp;&amp; a &gt;= b</code>, both of which are individually expressible.</p>
<h3 id="conclusion">Conclusion</h3>
<p>I only worked on a certain part of the Constraint Elimination pass. There is still more to discover inside this pass, such as, adding facts for loop induction variables. Lastly, I want to express my gratitude to Dr. John Regehr for his valuable advice on this project. Thanks, John!</p>

</article>

                
    
    
        
        <footer class="site-footer">
            <p>&copy; 2025  :)</p>
        </footer>
    


            </div>
        </main>
    </body>
</html>
